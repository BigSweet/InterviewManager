##插件化
1，类加载，根据apk的路径,通过反射创建dexclassloader，在获取系统的classloader，获取classloader中的pathlist的elements数组，
里面存放的是dex文件，将dexclassloader的elements[]数组插入到系统classloader的element数组中，让系统支持加载插件中的类
就可以实现加载插件类的功能
2，资源加载 也是通过反射和apk路径获取assetmanager，在通过assetmanager获取resource，通过这个resource去访问插件中的资源
3，插件的生命周期，通过占坑的一个activity，通过hook和反射，在activitymanager.startactivity的时候把这个占坑的activity替换成插件的activity，绕过ams验证，在applicationthread发送消息通知activitythread，去启动activity的时候，hook，handler，给handler添加一个callback，优先执行callback，在callback中将插件activity替换回来，实现跨越跳转插件activity的一个效果

第三步具体实现
首先通过反射获取IActivityManager的对象
通过动态代理hook住IActivityManager.startActivity方法，hook他的intent方法，将目标activity换成我们的占坑的activity，在通过mInstanceField.set(gDefault, proxy)塞到framework中

在ams验证通过之后
ams会通知applicationthread，在通过activitythread去真正的启动activity

通过反射获取ActivityThread对象中的mH handler
通过给这个handler赋值mCallback，当启动activity的message发送过来的时候，会触发callback
的handlermessage方法，
在message = LAUNCH_ACTIVITY（100）的时候，修改回来intent (在Android O之前)走这个message
在message = EXECUTE_TRANSACTION（159）的时候在将intent设置为目标的activity



##组件化
一个APP分为多个组件，这些组件之间都是解耦的，通过新建phone moudle tablet的形式实现单个组件能单独运行
他们之间的通信是通过路由框架 比如阿里的arouter框架来通信
要注意他们的manifest的合并，每个组件的application要保留俩个，一个是来单独运行的时候用，一个用来合并到主moudle的时候用

可以通过设置源集来指定特定的文件夹，将不需要的文件夹（debug文件夹）不打包进apk

```
 sourceSets {
        main {
            java.srcDirs = ['src/main/java', 'src/friend/java/', 'src/catgory/java/', 'src/duanzi/java/', 'src/my/java']

            res.srcDirs = ['src/main/res', 'src/friend/res/', 'src/catgory/res/', 'src/duanzi/res/', 'src/my/res']
            jniLibs.srcDirs = ['libs']
        }
    }
```

路由框架的原理是通过自定义注解，比如在activity上标记一个注解，在编译的时候，通过反射拿到所有的标记了这个注解的activity，并存储在一个map里面，这样就能实现他们之间的跳转和通信