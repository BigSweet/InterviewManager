##插件化
1，类加载，通过反射创建dexclassloader，在获取系统的classloader，根据apk的路径，将插件的classloader合并到系统的classloader中
就可以实现加载插件类的功能
2，资源加载 也是通过反射和apk路径获取assetmanager，在通过assetmanager获取resource，通过这个resource去访问插件中的资源
3，插件的生命周期，通过占坑的一个activity，通过hook和反射，在startactivity的时候把这个占坑的activity替换成插件的activity，绕过ams验证，在启动之后在替换回来，实现跨越跳转插件activity的一个效果

第三步具体实现
首先通过反射获取IActivityManager的对象
通过动态代理检测IActivityManager.startActivity方法，将目标activity换成我们的占坑的activity，在通过mInstanceField.set(gDefault, proxy)塞到framework中

在ams验证通过之后
ams会通知applicationthread，在通过activitythread去真正的启动activity

通过反射获取ActivityThread对象中的mH handler
通过给这个handler赋值mCallback，当启动activity的message发送过来的时候，会触发callback
的handlermessage方法，
在message = LAUNCH_ACTIVITY（100）的时候，修改回来intent (在Android O之前)走这个message
在message = EXECUTE_TRANSACTION（159）的时候在将intent设置为目标的activity




##组件化
一个APP分为多个组件，这些组件之间都是解耦的，通过新建phone moudle tablet的形式实现单个组件能单独运行
他们之间的通信是通过路由框架 比如阿里的arouter框架来通信
要注意他们的manifest的合并，组件的application要保留俩个，一个是来单独运行的时候用，一个用来合并到主moudle的时候用
路由框架的原理是通过自定义注解，比如在activity上标记一个注解，在编译的时候，通过反射拿到所有的标记了这个注解的activity，并存储在一个map里面，这样就能实现他们之间的跳转和通信