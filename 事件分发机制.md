##事件分发机制

java层传递机制，首先是activity的dispatchtouchevent触发，

在触发phonewindows的dispatchtouchevent，在触发DecorView的dispatchTouchEvent,decorview是继承viewgroup的，最后在触发viewgroup的dispatchtouchevent

viewgroup触发dispatchTouchEvent后，先判断onInterceptTouchEvent是否拦截，如果不拦截就获取点击区域的坐标，循环子view，获取子view的坐标，通过坐标来判断点击的是哪个子view，触发子view的dispatchTouchEvent，如果点击的是空白区域target==null就会触发super.dispatchTouchEvent(ev)

view的事件分发被点击后先调用dispatchTouchEvent，然后判断是否设置了onTouch事件mOnTouchListener是否为空，按钮是否是可点击的，在调用onTouchEvent，在MotionEvent.ACTION_UP里面调用performClick，如果设置了onclicklistener就会调用onclick事件



经典内部拦截

当为down的时候getParent().requestDisallowInterceptTouchEvent(true);

```
子view
case MotionEvent.ACTION_DOWN: {
               getParent().requestDisallowInterceptTouchEvent(true);
               break;
           }
           case MotionEvent.ACTION_MOVE: {
               int deltaX = x - mLastX;
               int deltaY = y - mLastY;
               if (Math.abs(deltaX) > Math.abs(deltaY)) {
                   getParent().requestDisallowInterceptTouchEvent(false);
               }
               break;
           }
```

```
父view
       if (event.getAction() == MotionEvent.ACTION_DOWN) {
           super.onInterceptTouchEvent(event);
           return false;
       }

       return true;
```

```
if (disallowIntercept) {
            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
        } else {
            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
        }
结果为mGroupFlags|= FLAG_DISALLOW_INTERCEPT;

但是在dispatch中如果为down事件，会触发resetTouchState();
mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
这个时候disallowIntercept=false
如果onInterceptTouchEvent还是返回true，那么子view的requestDisallowInterceptTouchEvent会没有效果
所以父view判断在down的时候返回false，这样intercepted为false，父view的down事件才会执行。才能触发子view的down事件
```

```
同时down事件会给mFirstTouchTarget赋值 target.next为null
 private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget;
        mFirstTouchTarget = target;
        return target;
    }
```

```
 TouchTarget target = mFirstTouchTarget;
while (target != null) {
    final TouchTarget next = target.next;
    down事件的时候mFirstTouchTarget不为null但是mFirstTouchTarget.next为null
```

下面为move事件

requestDisallowInterceptTouchEvent(false)

```java
requestDisallowInterceptTouchEvent (disallowIntercept)
  如果传过来的是false
  
 			 if (disallowIntercept) {
            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
        } else {
            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
        }
final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
disallowIntercept就为false
  if (!disallowIntercept) {
      intercepted = onInterceptTouchEvent(ev);
      ev.setAction(action); 
     }
intercepted为true
  
 
```

```
 final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        
   cancelChild为true
```

```
if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }
  cancelChild为true，就会给子view一个cancle事件ACTION_CANCEL这次move事件结束
   if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
    mFirstTouchTarget = next;
    mFirstTouchTarget会被置为null
```

接下来是下一次move事件

```
if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }
            
  直接走到else语句
  intercepted = true
  mFirstTouchTarget=null
  
  if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
            
     child为null
     if (child == null) {
                handled = super.dispatchTouchEvent(event);
            }
     调用自身的dispatchTouchEvent处理滑动
     到此requestDisallowInterceptTouchEvent(false)才生效
```





