##热修复
新apk和旧的apk通过dexbiff算法对比生成差异包,差异包通过比对文件的MD5值，把修改过的文件打进差异包，差异包下发到服务器，下载到手机指定的路径,
通过这个下载的路径生成dexclassloader，获取dexclassloader中的的pathlist，在获取Element数组，然后获取系统的pathclassloader和他的element数组，把这个差异包的Element数组塞到系统默认的element数组里面。通过反射把新的element数组设置给pathclassloader然后下次启动的时候就会加载差异包的dex类
双亲委托机制
父类加载过的dex，子类不会再去加载。保证所有的dex只会被加载一次。节省加载效率，防止核心系统类被篡改

资源修复
获取补丁文件，通过比较算法，生成差异包，放入一个指定的目录，通过这个路径获取AssertManager，通过assertmanager获取asset，然后将获取当前resource的assets字段设置为前面获取到的那个asset，这样getresource的时候就能找到补丁包里面的resource了

so文件的修复
通过比对和合成生成一个新的so文件，通过System.load方法加载so文件

热修复框架整理
课程百度网盘
https://pan.baidu.com/s/1nxFak_RH0NJd6UB55ABZPw
提取码：b0cm
andfix热修复
新旧apk通过patch工具生成patch补丁包，补丁包中会标记有bug的方法，为这个方法添加一个注解。然后将补丁包下发到手机内存后，通过dexclassloader加载这个dex补丁包，获取类中标记了自定义注解的这个方法，在C++层对这个方法进行重新赋值。达到一个修复的效果
美团robust热修复
通过字节码动态插桩。为每一个类都添加了成员变量。每个方法中，都添加了这个变量的判断。如果这个变量不为空，就会代理这个方法。
补丁文件dex通过dexclassloader加载后，通过反射生成对应类的插桩接口的实现，代理这个方法。修复bug


tinker和QQ空间热修复
新apk和旧的apk通过dexbiff算法对比生成差异包,差异包下发到服务器，下载到手机指定的路径,
通过这个下载的路径生成dexclassloader，获取dexclassloader中的的pathlist，在获取Element数组，然后获取系统的pathclassloader和他的element数组，把这个差异包的Element数组塞到系统默认的element数组里面。通过反射把新的element数组设置给pathclassloader然后下次启动的时候就会加载差异包的dex类
双亲委托机制
父类加载过的dex，子类不会再去加载。保证所有的dex只会被加载一次。节省加载效率，防止核心系统类被篡改


##class的加载过程
加载-》验证-》准备-》解析》初始化-》使用-》卸载
class.forname()会对类进行初始化操作
classloader.loadclass不会对类进行初始化

android9.0
this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);
dexfiles为构造函数中传入的ByteBuffer[] dexFiles，直接循环这个数组将buf用DexFile包装在添加到element数组中

android5.0
this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);
dexpath经过splitDexPath转换为list<file>,循环这个files。如果是目录直接添加到element数组中，如果是文件判断后缀是否是.dex
通过DexFile.loadDex(file.getPath(), optimizedPath, 0)转换为dex文件在添加到element数组中
elements.add(new Element(file, false, zip, dex));

android4.0
this.dexElements =makeDexElements(splitDexPath(dexPath), optimizedDirectory);
循环这个files，判断后缀是否是.dex如果是直接添加到element数组中，如果不是，用ZipFile包装，在通过dex = loadDexFile(file, optimizedDirectory);转换为dex文件，最后都是通过elements.add(new Element(file, zip, dex));添加到数组中


当一个dex中的类引用了另外的dex的类，那么在做校验的时候就会抛出异常。前提是这个类被标记了CLASS_ISPREVERIFIED标志
如果directMethods方法中直接引用到的类和clazz在同一个dex中，就会被打上CLASS_ISPREVERIFIED标志，
解决办法：在所有类的构造函数中插入一个单独的index中的类中的引用，防止了类被打上CLASS_ISPREVERIFIED的标志